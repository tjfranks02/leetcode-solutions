/**
 * Solution where you use a map to keep track of the last index of each number. If you see a number
 * that you've seen before, check if the difference between the current index and the last index is
 * less than or equal to k. If it is, return true. Otherwise, update the last index of the number
 * to the current index.
 * 
 * The above text was generated by copilot :) 
 * 
 * This is still really slow for some reason. Don't know if leetcode is just having a moment or if
 * it is genuinely really inefficient. Seems pretty close to neetcode's solution.
*/
class Solution {
public:
    bool containsNearbyDuplicate(vector<int>& nums, int k) {
        map<int, int> seen;

        for (int i = 0; i < nums.size(); i++) {
            int num = nums[i];

            if (!seen.count(num) || i - seen[num] > k) {
                seen[num] = i;
            } else {
                return true;
            }
        }

        return false;
    }
};